import { d as documentFunction, s as sakura, _ as __vitePreload, U as Util, I as I18nFormat } from "../main.min.js";
import "../assets/_commonjsHelpers-ca272635.js";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
class Post {
  autoCalculateSubmenuPosition() {
    const reword = sakura.getThemeConfig("post", "reward", Array);
    if (!reword || reword.length === 0) {
      return;
    }
    const rewordOpenElement = document.querySelector(".reward-open");
    if (!rewordOpenElement) {
      return;
    }
    const rewardMainElement = rewordOpenElement.querySelector(".reward-main");
    if (!rewardMainElement) {
      return;
    }
    const parentWidth = rewordOpenElement.offsetWidth;
    rewardMainElement.style.visibility = "hidden";
    rewardMainElement.style.display = "block";
    const subWidth = rewardMainElement.offsetWidth;
    console.log(parentWidth, subWidth);
    rewardMainElement.style.display = "none";
    rewardMainElement.style.visibility = "visible";
    const subLeft = parentWidth / 2 - subWidth / 2;
    rewardMainElement.style.left = `${subLeft}px`;
  }
  registerOriginalPostCopy() {
    var _a;
    const contentElement = document.querySelector(".entry-content");
    if (!contentElement) {
      return;
    }
    if (sakura.getPageConfig("isOriginal") == "false" || !((_a = sakura.getThemeConfig("post", "post_original_copy", Boolean)) == null ? void 0 : _a.valueOf())) {
      return;
    }
    contentElement.addEventListener("copy", (event) => {
      event.preventDefault();
      const selection = window.getSelection();
      if (!selection) {
        return;
      }
      const selectedText = selection.toString();
      if (!selectedText || selectedText.length < 30) {
        return;
      }
      const postArticleElement = document.querySelector(".post-article");
      if (!postArticleElement) {
        return;
      }
      const owner = postArticleElement.getAttribute("data-owner");
      const url = postArticleElement.getAttribute("data-url");
      const siteName = postArticleElement.getAttribute("data-siteName");
      let copyrightTemplateHtml = `
      ${sakura.translate(
        "post.copyright_template_html.info",
        `# 商业转载请联系作者获得授权，非商业转载请注明出处。<br>`
      )}
      ${sakura.translate(
        "post.copyright_template_html.license",
        `# 协议(License): 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)<br>`
      )}
      ${sakura.translate("post.copyright_template_html.author", `# 作者(Author): ${owner} <br>`, { postAuthor: owner })}
      ${sakura.translate("post.copyright_template_html.url", `# 链接(URL): ${url} <br>`, { postUrl: url })}
      ${sakura.translate("post.copyright_template_html.url", `# 来源(Source): ${siteName} <br>`, {
        siteName
      })}
      <br>
      `;
      const copyText = selection.toString();
      const htmlStr = `${copyrightTemplateHtml}${copyText.replace(/\r\n/g, "<br>")}`;
      const textStr = `${copyrightTemplateHtml.replace(/<br>/g, "\n")}${copyText.replace(/\r\n/g, "\n")}`;
      if (event.clipboardData) {
        event.clipboardData.setData("text/html", htmlStr);
        event.clipboardData.setData("text/plain", textStr);
      }
    });
  }
  async registerShareWechat() {
    const shareWechatElement = document.getElementById("qrcode");
    if (!shareWechatElement) {
      return;
    }
    const QRCode = await __vitePreload(() => import("../assets/browser-e6953f98.js").then((n) => n.b), true ? [] : void 0);
    QRCode.toCanvas(shareWechatElement, shareWechatElement.getAttribute("data-url"), {
      width: 120,
      color: {
        dark: "#000000",
        light: "#ffffff"
      }
    });
  }
  registerWordCountToast() {
    var _a, _b;
    if (!((_a = sakura.getThemeConfig("post", "post_word_count_toast", Boolean)) == null ? void 0 : _a.valueOf())) {
      return;
    }
    const contentElement = document.querySelector(".entry-content");
    if (!contentElement) {
      return;
    }
    const postWordCount = Util.getWordCount(contentElement);
    if (postWordCount > 0) {
      const seconds = Util.caclEstimateReadTime(postWordCount);
      let type = "NORMAL";
      if (seconds <= 60 * 10) {
        type = "NORMAL";
      } else if (seconds > 60 * 10 && seconds <= 60 * 30) {
        type = "MEDIUM";
      } else {
        type = "DIFFICULTY";
      }
      let remind = "";
      const timeString = I18nFormat.secondToTimeString(seconds);
      if (window.innerWidth > 860) {
        const defaultRemind = {
          normal: "文章篇幅适中，可以放心阅读。",
          medium: "文章比较长，建议分段阅读。",
          difficulty: "文章内容已经很陈旧了，也许不再适用！"
        };
        remind = ((_b = sakura.getThemeConfig("post", `post_word_count_toast_${type.toLowerCase()}`, String)) == null ? void 0 : _b.valueOf()) || sakura.translate("post.word_count_toast.remind", defaultRemind[type.toLowerCase()], {
          context: type.toLowerCase()
        });
      }
      this.createPostToast(
        contentElement,
        sakura.translate(
          "post.word_count_toast.content",
          `文章共 <b>${postWordCount}</b> 字，阅读完预计需要 <b>${timeString}</b>。${remind}`,
          {
            postWordCount,
            timeString,
            remind
          }
        ),
        type,
        "word_count"
      );
    }
  }
  registerEditTimeToast() {
    var _a, _b;
    const contentElement = document.querySelector(".entry-content");
    if (!contentElement) {
      return;
    }
    if (!((_a = sakura.getThemeConfig("post", "post_edit_time_toast", Boolean)) == null ? void 0 : _a.valueOf())) {
      return;
    }
    if (!sakura.getPageConfig("postLastModifyTime")) {
      return;
    }
    const postLastModifyTime = sakura.getPageConfig("postLastModifyTime");
    const editTime = new Date(postLastModifyTime);
    const time = (/* @__PURE__ */ new Date()).getTime() - editTime.getTime();
    let type = "NORMAL";
    if (time <= 1e3 * 60 * 60 * 24 * 30) {
      type = "NORMAL";
    } else if (time > 1e3 * 60 * 60 * 24 * 30 && time <= 1e3 * 60 * 60 * 24 * 90) {
      type = "MEDIUM";
    } else {
      type = "DIFFICULTY";
    }
    let remind = "";
    if (window.innerWidth > 860) {
      const defaultRemind = {
        normal: "近期有所更新，请放心阅读！",
        medium: "文章内容已经有一段时间没有更新了，也许不再适用！",
        difficulty: "文章内容已经很陈旧了，也许不再适用！"
      };
      remind = ((_b = sakura.getThemeConfig("post", `post_edit_time_toast_${type.toLowerCase()}`, String)) == null ? void 0 : _b.valueOf()) || sakura.translate("post.edit_time_toast.remind", defaultRemind[type.toLowerCase()], {
        context: type.toLowerCase()
      });
    }
    const sinceLastTime = I18nFormat.RelativeTimeFormat(editTime.getTime());
    this.createPostToast(
      contentElement,
      sakura.translate("post.edit_time_toast.content", `文章内容上次编辑时间于 <b>${sinceLastTime}</b>。${remind}`, {
        sinceLastTime,
        remind
      }),
      type,
      "last_time"
    );
  }
  createPostToast(parentElement, message, type, className) {
    const types = {
      NORMAL: "rgba(167, 210, 226, 1)",
      MEDIUM: "rgba(255, 197, 160, 1)",
      DIFFICULTY: "rgba(239, 206, 201, 1)"
    };
    const toastDivString = `<div class="${className} minicode" style="background-color: ${types[type]}">
      <span class="content-toast">
        ${message}
      </span>
      <div class="hide-minicode">
        <span class="iconify iconify--small" data-icon="fa:times"></span>
      </div>
    </div>`;
    if (parentElement.querySelector(`.${className}`)) {
      return;
    }
    const parse = new DOMParser();
    const toastDocument = parse.parseFromString(toastDivString, "text/html");
    const toastElement = toastDocument.querySelector(`.${className}`);
    const hideMinicode = toastElement.querySelector(".hide-minicode");
    hideMinicode.addEventListener(
      "click",
      () => {
        toastElement.classList.add("hide");
      },
      { once: true }
    );
    parentElement.insertAdjacentElement("afterbegin", toastElement);
  }
}
__decorateClass([
  documentFunction()
], Post.prototype, "autoCalculateSubmenuPosition", 1);
__decorateClass([
  documentFunction()
], Post.prototype, "registerOriginalPostCopy", 1);
__decorateClass([
  documentFunction()
], Post.prototype, "registerShareWechat", 1);
__decorateClass([
  documentFunction()
], Post.prototype, "registerWordCountToast", 1);
__decorateClass([
  documentFunction()
], Post.prototype, "registerEditTimeToast", 1);
